/* $Id: stdio.h,v 1.4 2002/10/29 04:45:19 rex Exp $
 */
/*
 * stdio.h
 *
 * standard buffered input/output. Conforming to the Single UNIX(r)
 * Specification Version 2, System Interface & Headers Issue 5
 *
 * This file is part of the ReactOS Operating System.
 *
 * Contributors:
 *  Created by KJK::Hyperion <noog@libero.it>
 *
 *  THIS SOFTWARE IS NOT COPYRIGHTED
 *
 *  This source code is offered for use in the public domain. You may
 *  use, modify or distribute it freely.
 *
 *  This code is distributed in the hope that it will be useful but
 *  WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY
 *  DISCLAMED. This includes but is not limited to warranties of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 */
#ifndef __STDIO_H_INCLUDED__
#define __STDIO_H_INCLUDED__

/* INCLUDES */
#include <stddef.h>
#include <stdarg.h>
#include <unistd.h>
#include <sys/types.h>

/* OBJECTS */
extern char  *optarg;
extern int    opterr;
extern int    optind; /* LEGACY */
extern int    optopt;

/* TYPES */
typedef struct __tagFILE
{
 int _dummy;
} FILE;

typedef struct __tagfpos_t
{
 int _dummy;
} fpos_t;


/* CONSTANTS */
/* Size of <stdio.h> buffers. */
#define BUFSIZ (0x10000)

/* Maximum size in bytes of the longest filename string that the implementation
   guarantees can be opened. */
#define FILENAME_MAX (255)                           

/* Number of streams which the implementation guarantees can be open
   simultaneously. The value will be at least eight. */
#define FOPEN_MAX (8)

/* Input/output fully buffered. */
#define _IOFBF (1)
/* Input/output line buffered. */
#define _IOLBF (2)
/* Input/output unbuffered. */
#define _IONBF (3)

/* Maximum size of character array to hold ctermid() output. */
#define L_ctermid (255)
/* Maximum size of character array to hold cuserid() output. (LEGACY) */
#define L_cuserid (255)
/* Maximum size of character array to hold tmpnam() output. */
#define L_tmpnam  (255)

/* Minimum number of unique filenames generated by tmpnam(). Maximum number
   of times an application can call tmpnam() reliably. The value of TMP_MAX
   will be at least 10,000. */
#define TMP_MAX (0xFFFF)

/* End-of-file return value. */
#define EOF (-1)

/* default directory prefix for tempnam() */
#define P_tmpdir "/tmp/"

/* Standard error output stream. */
#define stderr ((FILE *)STDERR_FILENO)
/* Standard input stream. */
#define stdin  ((FILE *)STDIN_FILENO)
/* Standard output stream. */
#define stdout ((FILE *)STDOUT_FILENO)

/* PROTOTYPES */
void     clearerr(FILE *);
char    *ctermid(char *);
char    *cuserid(char *); /* LEGACY */
int      fclose(FILE *);
FILE    *fdopen(int, const char *);
int      feof(FILE *);
int      ferror(FILE *);
int      fflush(FILE *);
int      fgetc(FILE *);
int      fgetpos(FILE *, fpos_t *);
char    *fgets(char *, int, FILE *);
int      fileno(FILE *);
void     flockfile(FILE *);
FILE    *fopen(const char *, const char *);
int      fprintf(FILE *, const char *, ...);
int      fputc(int, FILE *);
int      fputs(const char *, FILE *);
size_t   fread(void *, size_t, size_t, FILE *);
FILE    *freopen(const char *, const char *, FILE *);
int      fscanf(FILE *, const char *, ...);
int      fseek(FILE *, long int, int);
int      fseeko(FILE *, off_t, int);
int      fsetpos(FILE *, const fpos_t *);
long int ftell(FILE *);
off_t    ftello(FILE *);
int      ftrylockfile(FILE *);
void     funlockfile(FILE *);
size_t   fwrite(const void *, size_t, size_t, FILE *);
int      getc(FILE *);
int      getchar(void);
int      getc_unlocked(FILE *);
int      getchar_unlocked(void);
int      getopt(int, char * const[], const char *); /* LEGACY */
char    *gets(char *);
int      getw(FILE *);
int      pclose(FILE *);
void     perror(const char *);
FILE    *popen(const char *, const char *);
int      printf(const char *, ...);
int      putc(int, FILE *);
int      putchar(int);
int      putc_unlocked(int, FILE *);
int      putchar_unlocked(int);
int      puts(const char *);
int      putw(int, FILE *);
int      remove(const char *);
int      rename(const char *, const char *);
void     rewind(FILE *);
int      scanf(const char *, ...);
void     setbuf(FILE *, char *);
int      setvbuf(FILE *, char *, int, size_t);
int      snprintf(char *, size_t, const char *, ...);
int      sprintf(char *, const char *, ...);
int      sscanf(const char *, const char *, int, ...);
char    *tempnam(const char *, const char *);
FILE    *tmpfile(void);
char    *tmpnam(char *);
int      ungetc(int, FILE *);
int      vfprintf(FILE *, const char *, va_list);
int      vprintf(const char *, va_list);
int      vsnprintf(char *, size_t, const char *, va_list);
int      vsprintf(char *, const char *, va_list);

/* MACROS */

#endif /* __STDIO_H_INCLUDED__ */

/* EOF */

